/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */           
/* REXX: VSELSYNC   Proc Created 02/06/2023   By Dave Clark        */           
/*                  Last Revised 02/13/2023                        */           
/*                                                                 */           
/*      This procedure  performs  a  synchronization  operation of */           
/* selected members in  a  designated  VSE  sub-library across two */           
/* systems -- the current (source)  system and a "remote" (target) */           
/* system designated in a  POWER JECL DEST parameter.   The source */           
/* sub- library is  supplied  as  an  EXEC  PARM  and the selected */           
/* member(s) is/are supplied as card input.                        */           
/*      The resulting output is  a  punched  recatalog job to both */           
/* the source and target  systems specified through separate POWER */           
/* JECL PUN statements (see sample  below).   The net effect is to */           
/* cause the selected VSE  sub-library  member attributes to match */           
/* on both systems.                                                */           
/*      NOTE that this  can  only  be  done  for members stored as */           
/* 80-byte source records (e.g.,  object,  phase, and dump members */           
/* are bypassed even if specifically selected).                    */           
/*                                                                 */           
/* // EXEC REXX=VSELSYNC,PARM='...'                                */           
/*                                                                 */           
/* Notes:                                                          */           
/* 1) Must be delimited by either commas, spaces, or both.         */           
/* 2) The order is positional -- unless keyword tags specified.    */           
/* 3) You cannot omit a positional argument and position the next. */           
/*                                                                 */           
/* Arguments: <SUBLIB=>lib.sublib                                  */           
/*            <PUNCH1=>{FE1|uraddr}                                */           
/*            <PUNCH2=>{FE2|uraddr}                                */           
/*                                                                 */           
/* Where: < >      encloses optional keywords and/or parameters;   */           
/*        { }      encloses a set of mutually exclusive options;   */           
/*         |       separates mutually exclusive options;           */           
/*        SUBLIB=  is an optional keyword tag;                     */           
/*        lib.sublib must be formatted according to the rules for  */           
/*                   the LIBR ACCESS SUBLIB= parameter;            */           
/*        PUNCH1=                                                  */           
/*        PUNCH2=  are optional keyword tags;                      */           
/*        uraddr   is a unit record address for the source punched */           
/*                   recatalog job (default, FE1) and a 2nd unit   */           
/*                   record address for the target punched         */           
/*                   recatalog job (default, FE2).                 */           
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */           
                                                                                
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */           
/* No warranty is expressed or implied.    Written by Dave L Clark */           
/* Neither the author nor the company is   Winsupply Group Srvcs.  */           
/* responsible for any loss or damage      3110 Kettering Blvd.    */           
/* resulting from the use of this code.    Dayton, OH  45439       */           
/* Source is provided on an as-is basis.   Phone (937)294-5331     */           
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */           
                                                                                
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */           
/* The following sample JCL  runs  the synchronization and punches */           
/* the recatalog jobs to the  RDR queue on the respective systems. */           
/* Thus,  the  source  system  is  designated  by  the  JOB  XDEST */           
/* parameter and the target  system  is  designated by the 2nd PUN */           
/* DEST parameter.   The 1st PUN  DEST parameter should specify an */           
/* asterisk to default to the  system on which the synchronization */           
/* job is running.                                                 */           
/*                                                                 */           
/*   * $$ JOB JNM=VSELSYNC,DISP=D,CLASS=0,XDEST=PROD               */           
/*   * $$ LST LST=SYSLST,DISP=D,CLASS=Z                            */           
/*   // JOB    VSELSYNC   VSE LIBRARY SYNCH ACROSS SYSTEMS         */           
/*   * $$ PUN PUN=FE1,CLASS=0,RBM=0,DEST=(*,PWR$JOB)      <SOURCE> */           
/*   * $$ PUN PUN=FE2,CLASS=0,RBM=0,DEST=(QUAS,PWR$JOB)   <TARGET> */           
/*   // EXEC   REXX=VSELSYNC,PARM='DAP.PROD'                       */           
/*   member1 type1                                                 */           
/*     .                                                           */           
/*     .                                                           */           
/*     .                                                           */           
/*   membern typen                                                 */           
/*   /* EOD                                                     */ */           
/*   /& EOJ                                                        */           
/*   * $$ EOJ                                                      */           
/*                                                                 */           
/* Note that the job must run in the BG partition because internal */           
/* segmentation is done for  the BG partition.   Also,  PUN output */           
/* class must be zero for this job  to be able to retrieve its own */           
/* punched  output.    And  don't  override   the  job  name  (JNM */           
/* parameter) on the PUN output for the same reason.               */           
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */           
                                                                                
/* ----------------------------------------------------------------- */         
/* Parse Source values                                               */         
/* ----------------------------------------------------------------- */         
                                                                                
  Parse Source _sys _env _pgm _tokens;                                          
                                                                                
  _True  = (0=0);            /* define boolean True value  */                   
  _False = (0=1);            /* define boolean False value */                   
                                                                                
                                                                                
  rc = 0;                                                                       
  Arg msg;                                                                      
                                                                                
/* ----------------------------------------------------------------- */         
/* Validate PARM arguments                                           */         
/* ----------------------------------------------------------------- */         
                                                                                
  If msg <> '' & msg <> '?' Then Do                                             
    Parse Value Space(Translate(msg,' ',',')) With ,                            
      sublib pun1 pun2 extra 1 'SUBLIB=' sublib2 .,                             
                             1 'PUNCH1=' pun21 .,                               
                             1 'PUNCH2=' pun22 .;                               
    If sublib2 <> '' Then sublib = sublib2;                                     
    If pun21   <> '' Then pun1   = pun21;                                       
    If pun22   <> '' Then pun2   = pun22;                                       
    If pun1    =  '' Then pun1   = 'FE1';                                       
    If pun2    =  '' Then pun2   = 'FE2';                                       
    If extra   <> '' Then Do                                                    
      Say ' Extraneous argument(s) specified:';                                 
      Say '    EXTRA='extra;                                                    
      msg = '';                                                                 
      rc = 12;                                                                  
    End                                                                         
    If sublib  = '' Then Do                                                     
      Say ' Required argument missing:';                                        
      Say '    SUBLIB='sublib;                                                  
      msg = '';                                                                 
      rc = 12;                                                                  
    End                                                                         
  End                                                                           
                                                                                
  If msg  = '' | msg  = '?' Then Do                                             
    Do n = 1 While Left(Sourceline(n),2) = '/*'                                 
      Say Sourceline(n);                                                        
    End                                                                         
    Exit rc;                                                                    
  End                                                                           
                                                                                
/* ----------------------------------------------------------------- */         
/* Process SYSIPT data                                               */         
/* ----------------------------------------------------------------- */         
                                                                                
  Say 'SYNCHRONIZE SUBLIB='sublib;                                              
                                                                                
  cardin.  = '';                                                                
  cardin.0 = 0;                                                                 
                                                                                
  "EXECIO * DISKR SYSIPT ( OPEN FINIS STEM cardin.";                            
  If rc <> 0 Then Do                                                            
    Say ' Error: EXECIO returned rc =' rc;                                      
    Exit 16;                                                                    
  End                                                                           
  If cardin.0 < 1 | cardin.1 = "" Then Do                                       
    Say ' Error: Nothing to synchronize.';                                      
    Exit 12;                                                                    
  End                                                                           
                                                                                
/* ----------------------------------------------------------------- */         
/* Process member list                                               */         
/* ----------------------------------------------------------------- */         
                                                                                
  Do n = 1 to cardin.0                                                          
    Parse Upper Value Space(Translate(cardin.n,' ','.')) With ,                 
      memnam memtyp .;                                                          
                                                                                
    If memnam = '',                                                             
    |  InStr('?',memnam),              /* generic not allowed */                
    |  InStr('*',memnam),              /* generic not allowed */                
    Then Do                                                                     
      Say FormatMessage('member name missing or unacceptable.');                
      Iterate;                                                                  
    End                                                                         
                                                                                
    If memtyp = '',                                                             
    |  InStr('?',memtyp),              /* generic not allowed */                
    |  InStr('*',memtyp),              /* generic not allowed */                
    |  memtyp = 'DUMP',                                                         
    |  memtyp = 'OBJ',                                                          
    |  memtyp = 'PHASE',                                                        
    |  memtyp = 'SYSDEBUG',                                                     
    Then Do                                                                     
      Say FormatMessage('member type missing or unacceptable.');                
      Iterate;                                                                  
    End                                                                         
                                                                                
    syslst.  = '';             /* Prepare LIBR output       */                  
    syslst.0 = 0;                                                               
    sysipt.  = '';             /* Extract member attributes */                  
    sysipt.0 = 2;                                                               
    sysipt.1 = ' ACCESS S='sublib;                                              
    sysipt.2 = ' LISTD  'memnam'.'memtyp;                                       
    Call InvokeLibr 'sysipt.', 'syslst.';                                       
    If syslst.0 > 11 Then Do   /* Check expected output */                      
      Say FormatMessage('too many member lines.');                              
      Iterate;                                                                  
    End                                                                         
    If Left(syslst.4 ,17) <> 'DIRECTORY DISPLAY',                               
    |  Left(syslst.6 ,17) <> '-----------------',                               
    |  Left(syslst.9 ,17) <> '-----------------',                               
    |  Left(syslst.11,17) <> 'L113I RETURN CODE',                               
    Then Do                                                                     
      Say FormatMessage('cannot interpret output.');                            
      Do i = 1 to syslst.0                                                      
        Say syslst.i                                                            
      End i                                                                     
      Exit 16                                                                   
    End                                                                         
                                                                                
    Parse Var syslst.10 member type created . ,                                 
                                 28 updated . ,                                 
                                 36 size code blks .;                   ;       
    If code <> 'R' Then Do                                                      
      Say FormatMessage('member not record format.');                           
      Iterate;                                                                  
    End                                                                         
                                                                                
/* ---- Submit recatalog job for source system ---- */                          
    Address JCL "// ASSGN SYSPCH,"pun1;                                         
    If rc <> 0 Then Do                                                          
      Say ' Error: Source SYSPCH assignment; rc =' rc;                          
    End                                                                         
                                                                                
    Call PunchCatalogJob;                                                       
                                                                                
/* ---- Submit recatalog job for target system ---- */                          
    Address JCL "// ASSGN SYSPCH,"pun2;                                         
    If rc <> 0 Then Do                                                          
      Say ' Error: Target SYSPCH assignment; rc =' rc;                          
    End                                                                         
                                                                                
    Call PunchCatalogJob;                                                       
                                                                                
/* ---- Segment output for separate entries    ---- */                          
    Address POWER "PSEGMENT BG,"pun1",IMM";                                     
    Address POWER "PSEGMENT BG,"pun2",IMM";                                     
                                                                                
/* ---- Target punch is handled automatically, but                              
        source punch needs some help.               */                          
    Call GetSourcePunAndSubmitJob;                                              
                                                                                
/* ---- Done with this member                  ---- */                          
    Say FormatMessage('member synchronized.');                                  
                                                                                
  End n                                                                         
                                                                                
/* ----------------------------------------------------------------- */         
/* Return to caller                                                  */         
/* ----------------------------------------------------------------- */         
                                                                                
  Say 'Synchronization completed.';                                             
                                                                                
Exit rc;                                                                        
                                                                                
/* ----------------------------------------------------------------- */         
/* Internal procedures                                               */         
/* ----------------------------------------------------------------- */         
                                                                                
PunchCatalogJob:                                                                
  sysipt.0 = 4;              /* Punch job prefix */                             
  sysipt.1 = "* $$ LST LST=SYSLST,DISP=D,CLASS=Z        ";                      
  sysipt.2 = "// JOB    VSELSYNC   VSE LIBRARY SYNCH    ";                      
  sysipt.3 = "// EXEC   PGM=LIBR,SIZE=256K,PARM='MSHP'  ";                      
  sysipt.4 = "ACCESS SUBLIB="sublib;                                            
  sysipt.5 = "";                                                                
  "EXECIO * DISKW SYSPCH ( OPEN FINIS STEM sysipt.";                            
                                                                                
  syslst.  = '';             /* Prepare LIBR output       */                    
  syslst.0 = 0;                                                                 
  sysipt.0 = 2;              /* Punch member content w/ header + eod */         
  sysipt.1 = ' ACCESS S='sublib;                                                
  sysipt.2 = ' PUNCH  'memnam'.'memtyp;                                         
  sysipt.3 = '';                                                                
  Call InvokeLibr 'sysipt.', 'syslst.';                                         
                                                                                
  sysipt.0 = 1;              /* Punch job suffix */                             
  sysipt.1 = "/& EOJ";                                                          
  sysipt.2 = "";                                                                
  "EXECIO * DISKW SYSPCH ( OPEN FINIS STEM sysipt.";                            
Return rc;                                                                      
                                                                                
FormatMessage: Procedure Expose memnam memtyp;                                  
  Parse Arg _msg;            /* get the message text   */                       
  _pfx = ' 'memnam'.'memtyp; /* set the message prefix */                       
  _pfx = _pfx||Copies(' ',18-Length(_pfx));                                     
Return _pfx' '_msg;          /* return formatted message */                     
                                                                                
GetSourcePunAndSubmitJob: Procedure Expose _pgm;                                
  z = SYSVAR('SYSPOWJNM');                                                      
  z = SYSVAR('SYSPOWJNUM');                                                     
  z = SYSVAR('SYSPOWJCLS'); /* requires ptf */                                  
  jnm = Strip(SYSPOWJNM);                                                       
  jno = Strip(SYSPOWJNUM);                                                      
  jcl = Strip(SYSPOWJCLS);                                                      
  rc = GetPunOutput(jnm,jno,jcl,'Delete');                                      
  If rc = 0 Then Do                                                             
    sysipt.  = '';                                                              
    sysipt.0 = 1;                                                               
    sysipt.1 = '* $$ JOB JNM='jnm',CLASS='jcl',DISP=D';                         
    Do i = 1 to result.0                                                        
      n = sysipt.0 + 1;                                                         
      sysipt.n = result.i;                                                      
      sysipt.0 = n;                                                             
    End                                                                         
    n = sysipt.0 + 1;                                                           
    sysipt.n = '* $$ EOJ';                                                      
    sysipt.0 = n;                                                               
                                                                                
    Call SubmitJob 'sysipt.';                                                   
  End                                                                           
Return rc;                                                                      
                                                                                
/* ----------------------------------------------------------------- */         
/* Return a numeric value formatted with commas.                     */         
/* ----------------------------------------------------------------- */         
Commas: Procedure                                                               
  Arg str;                                                                      
  If Pos(".",str) < 1 Then decm = "";                                           
  Else decm = SubStr(str,Pos(".",str));                                         
  str  = Left(str,Length(str)-Length(decm));                                    
  Do i = Length(str)-3 To 1 By -3                                               
    str = Left(str,i)","SubStr(str,i+1);                                        
  End                                                                           
Return str||decm;                                                               
                                                                                
/* ----------------------------------------------------------------- */         
/* Return a readable and scaled file size specification.             */         
/* ----------------------------------------------------------------- */         
FileSize: Procedure;                                                            
  Arg nbr,cisize,type;                                                          
  If type == 'XLDS' Then Do                                                     
    nbr = nbr * cisize;                                                         
    Return FormatScaled(nbr,5,2,1,1000,"BKMGTP");                               
  End                                                                           
Return FormatScaled(nbr,5,2,1,1024,"BKMGTP");                                   
                                                                                
/* ----------------------------------------------------------------- */         
/* Return a readable and scaled numeric value with commas.           */         
/* ----------------------------------------------------------------- */         
FormatScaled: Procedure;                                                        
  Arg nbr,wdt,whl,dcm,factor,radix;                                             
  Do scale = 1 To Length(radix)                                                 
    If nbr < (10**whl) Then Leave;                                              
    nbr = nbr / factor;                                                         
  End                                                                           
Return Right(Commas(Format(nbr,,dcm))||SubStr(radix,scale,1),wdt);              
                                                                                
/* ----------------------------------------------------------------- */         
/* IF Function whose first argument is a Boolean value that          */         
/*             determines which of the other two arguments to return */         
/* ----------------------------------------------------------------- */         
IFF: Procedure;                                                                 
  Parse Arg cond,trueValue,falseValue;                                          
  If cond Then Return trueValue;                                                
Return falseValue;                                                              
/* ----------------------------------------------------------------- */         
                                                                                
InList:                                                                         
  If WordPos(Arg(1),Arg(2)) > 0 Then Return _True;                              
Return _False;                                                                  
                                                                                
InStr:                                                                          
  If Pos(Arg(1),Arg(2)) > 0 Then Return _True;                                  
Return _False;                                                                  
                                                                                
Kword:                                                                          
  If Pos('=',Arg(1)) > 0 Then Return _True;                                     
Return _False;                                                                  
                                                                                
/* ----------------------------------------------------------------- */         
/* Send "SAY" output to both console and printer.                    */         
/* ----------------------------------------------------------------- */         
SayAll: Procedure;                                                              
  Parse Arg msg;                                                                
  oldout = ASSGN('STDOUT','SYSLOG');                                            
  Say msg;                                                                      
  oldout = ASSGN('STDOUT','SYSLST');                                            
  Say msg;                                                                      
Return;                                                                         
                                                                                
/* --------------------------------------------------------------- */           
/* Return Submitted Job Output    (WARNING! Tricky compound func!) */           
/* --------------------------------------------------------------- */           
GetJobOutput:                                                                   
  result = Arg(1);                                                              
Return GetJobOutput_(Arg(1),Arg(2),Arg(3));                                     
                                                                                
GetJobOutput_: Procedure Expose (result) _pgm result. result_format;            
  Arg stem,class,queue;                                                         
  result.  = '';                                                                
  result.0 = 0;                                                                 
  z = OUTTRAP('err.','*','NOCONCAT');                                           
  Address POWER "PUTQE RDR WAIT 300 STEM" stem "LONGREC",                       
                           "JOBNAME jnm JOBNUM jno GENCM";                      
  If rc = 0 Then Do                                                             
    If Left(queue,1) = 'P' Then                                                 
      rc = GetPunOutput(jnm,jno,class,'Delete');                                
    Else Do                                                                     
      rc = GetLstOutput(jnm,jno,class,'Delete');                                
    End                                                                         
  End                                                                           
  Else Do                                                                       
    Say _pgm': Error in submitted POWER RDR job; rc =' rc;                      
    Do z = 1 to err.0                                                           
      Say ' ' err.z;                                                            
    End                                                                         
  End                                                                           
Return rc;                                                                      
                                                                                
/* --------------------------------------------------------------- */           
/* Retrieve LST Job Output                                         */           
/* --------------------------------------------------------------- */           
GetLstOutput: Procedure Expose _pgm result. result_format;                      
  Arg jnm,jno,class,opt;                                                        
  result.  = '';                                                                
  result.0 = 0;                                                                 
  z = OUTTRAP('err.','*','NOCONCAT');                                           
  Address POWER "GETQE LST JOBNAME" jnm "JOBNUM" jno "CLASS" class,             
                "STEM result. FORMAT result_format CTRLREC";                    
  If rc <> 0 Then Do                                                            
    Say _pgm': Error retrieving POWER LST queue entry; rc =' rc;                
    Do z = 1 to err.0                                                           
      Say ' ' err.z;                                                            
    End                                                                         
  End                                                                           
  Else Do                                                                       
    If Left(opt,1) = 'D' Then Do                                                
      z = OUTTRAP('err.','*','NOCONCAT');                                       
      Address POWER "PDELETE LST,"jnm","jno",CCLASS="class;                     
      If rc <> 0 Then Do                                                        
        Say _pgm': Error deleting POWER LST queue entry; rc =' rc;              
        Do z = 1 to err.0                                                       
          Say ' ' err.z;                                                        
        End                                                                     
      End                                                                       
    End                                                                         
  End                                                                           
Return rc;                                                                      
                                                                                
/* --------------------------------------------------------------- */           
/* Retrieve PUN Job Output                                         */           
/* --------------------------------------------------------------- */           
GetPunOutput: Procedure Expose _pgm result.;                                    
  Arg jnm,jno,class,opt;                                                        
  result.  = '';                                                                
  result.0 = 0;                                                                 
  z = OUTTRAP('err.','*','NOCONCAT');                                           
  Address POWER "GETQE PUN JOBNAME" jnm "JOBNUM" jno "CLASS" class,             
                "STEM result.";                                                 
  If rc <> 0 Then Do                                                            
    Say _pgm': Error retrieving POWER PUN queue entry; rc =' rc;                
    Do z = 1 to err.0                                                           
      Say ' ' err.z;                                                            
    End                                                                         
  End                                                                           
  Else Do                                                                       
    If Left(opt,1) = 'D' Then Do                                                
      z = OUTTRAP('err.','*','NOCONCAT');                                       
      Address POWER "PDELETE PUN,"jnm","jno",CCLASS="class;                     
      If rc <> 0 Then Do                                                        
        Say _pgm': Error deleting POWER PUN queue entry; rc =' rc;              
        Do z = 1 to err.0                                                       
          Say ' ' err.z;                                                        
        End                                                                     
      End                                                                       
    End                                                                         
  End                                                                           
Return rc;                                                                      
                                                                                
/* --------------------------------------------------------------- */           
/* Submit Job Only                (WARNING! Tricky compound func!) */           
/* --------------------------------------------------------------- */           
SubmitJob:                                                                      
  result = Arg(1);                                                              
Return SubmitJob_(Arg(1));                                                      
                                                                                
SubmitJob_: Procedure Expose (result) _pgm;                                     
  Arg stem;                                                                     
  z = OUTTRAP('err.','*','NOCONCAT');                                           
  Address POWER "PUTQE RDR STEM" stem "LONGREC";                                
  If rc <> 0 Then Do                                                            
    Say _pgm': Error in submitted POWER RDR job; rc =' rc;                      
    Do z = 1 to err.0                                                           
      Say ' ' err.z;                                                            
    End                                                                         
  End                                                                           
Return rc;                                                                      
                                                                                
/* --------------------------------------------------------------- */           
/* Invoke LIBR Commands      (WARNING! Tricky compound procedure!) */           
/* --------------------------------------------------------------- */           
InvokeLibr:                                                                     
  _librinp_ = Arg(1);                                                           
  _librout_ = Arg(2);                                                           
Return _InvokeLibr_(Arg(1),Arg(2));                                             
                                                                                
_InvokeLibr_: Procedure Expose (_librinp_) (_librout_);                         
  Arg istem,ostem;                                                              
  y = REXXIPT(istem);                                                           
  y = OUTTRAP(ostem,'*','NOCONCAT');                                            
  Address LINK 'LIBR';       /* Invoke LIBR */                                  
  If rc <> 0 Then Do                                                            
    Say 'ERROR:: During LIBR invocation; rc =' rc;                              
    Do i = 1 to Value(istem||0)                                                 
      Say 'SYSIPT:' Value(istem||i)                                             
    End i                                                                       
    Do i = 1 to Value(ostem||0)                                                 
      Say 'SYSLST:' Value(ostem||i)                                             
    End i                                                                       
  End                                                                           
  y = REXXIPT('OFF');                                                           
Return rc;                                                                      
                                                                                
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */         
